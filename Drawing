local Camera = workspace.CurrentCamera
local GuiService = cloneref(game:GetService("GuiService"))
local CoreGui = (gethui and gethui() or cloneref(game:GetService("CoreGui"))
local Offset = GuiService:GetGuiInset()

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Drawing"
ScreenGui.IgnoreGuiInset = true
ScreenGui.DisplayOrder = 0x7fffffff
ScreenGui.Parent = CoreGui

-- Drawing container
local drawingUI = Instance.new("Frame")
drawingUI.Name = "Container"
drawingUI.Size = UDim2.fromScale(1, 1)
drawingUI.BackgroundTransparency = 1
drawingUI.Parent = ScreenGui

-- Configuration
local drawingIndex = 0
local drawingFontsEnum = {
    [0] = Font.fromEnum(Enum.Font.Roboto),
    [1] = Font.fromEnum(Enum.Font.Legacy),
    [2] = Font.fromEnum(Enum.Font.SourceSans),
    [3] = Font.fromEnum(Enum.Font.RobotoMono)
}

-- Base object for all drawing types
local baseDrawingObj = setmetatable({
    Visible = true,
    ZIndex = 0,
    Transparency = 1,
    Color = Color3.new(),
    Remove = function(self)
        setmetatable(self, nil)
    end,
    Destroy = function(self)
        setmetatable(self, nil)
    end
}, {
    __add = function(t1, t2)
        local result = table.clone(t1)
        for index, value in t2 do
            result[index] = value
        end
        return result
    end
})

-- Utility functions
local function getFontFromIndex(fontIndex)
    return drawingFontsEnum[fontIndex]
end

local function convertTransparency(transparency)
    return math.clamp(1 - transparency, 0, 1)
end

local function applyOffset(position)
    return Vector2.new(position.X + Offset.X, position.Y + Offset.Y)
end

-- Main library
local DrawingLib = {}
DrawingLib.Fonts = {
    ["UI"] = 0,
    ["System"] = 1,
    ["Plex"] = 2,
    ["Monospace"] = 3
}

-- Drawing type implementations
local drawingTypes = {}

-- Line implementation
drawingTypes.Line = function()
    local lineObj = ({
        From = Vector2.zero,
        To = Vector2.zero,
        Thickness = 1
    } + baseDrawingObj)

    local lineFrame = Instance.new("Frame")
    lineFrame.Name = drawingIndex
    lineFrame.AnchorPoint = Vector2.one * 0.5
    lineFrame.BorderSizePixel = 0
    lineFrame.BackgroundColor3 = lineObj.Color
    lineFrame.Visible = lineObj.Visible
    lineFrame.ZIndex = lineObj.ZIndex
    lineFrame.BackgroundTransparency = convertTransparency(lineObj.Transparency)
    lineFrame.Size = UDim2.new()
    lineFrame.Parent = drawingUI

    local function updateLine()
        local from, to = lineObj.From, lineObj.To
        local direction = to - from
        local center = (to + from) / 2
        local distance = direction.Magnitude
        local theta = math.deg(math.atan2(direction.Y, direction.X))

        local offsetCenter = applyOffset(center)
        lineFrame.Position = UDim2.fromOffset(offsetCenter.X, offsetCenter.Y)
        lineFrame.Rotation = theta
        lineFrame.Size = UDim2.fromOffset(distance, lineObj.Thickness)
    end

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(lineObj[index]) == "nil" then return end

            lineObj[index] = value
            
            if index == "From" or index == "To" then
                updateLine()
            elseif index == "Thickness" then
                updateLine()
            elseif index == "Visible" then
                lineFrame.Visible = value
            elseif index == "ZIndex" then
                lineFrame.ZIndex = value
            elseif index == "Transparency" then
                lineFrame.BackgroundTransparency = convertTransparency(value)
            elseif index == "Color" then
                lineFrame.BackgroundColor3 = value
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    lineFrame:Destroy()
                    lineObj.Remove(self)
                    return lineObj:Remove()
                end
            end
            return lineObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Text implementation
drawingTypes.Text = function()
    local textObj = ({
        Text = "",
        Font = DrawingLib.Fonts.UI,
        Size = 0,
        Position = Vector2.zero,
        Center = false,
        Outline = false,
        OutlineColor = Color3.new()
    } + baseDrawingObj)

    local textLabel = Instance.new("TextLabel")
    local uiStroke = Instance.new("UIStroke")
    
    textLabel.Name = drawingIndex
    textLabel.AnchorPoint = Vector2.one * 0.5
    textLabel.BorderSizePixel = 0
    textLabel.BackgroundTransparency = 1
    textLabel.Visible = textObj.Visible
    textLabel.TextColor3 = textObj.Color
    textLabel.TextTransparency = convertTransparency(textObj.Transparency)
    textLabel.ZIndex = textObj.ZIndex
    textLabel.FontFace = getFontFromIndex(textObj.Font)
    textLabel.TextSize = textObj.Size
    
    uiStroke.Thickness = 1
    uiStroke.Enabled = textObj.Outline
    uiStroke.Color = textObj.OutlineColor
    
    textLabel.Parent = drawingUI
    uiStroke.Parent = textLabel
    
    local function updatePosition()
        local textBounds = textLabel.TextBounds
        local offset = textBounds / 2
        local position = textObj.Position
        
        textLabel.Size = UDim2.fromOffset(textBounds.X, textBounds.Y)
        
        local offsetPos = applyOffset(Vector2.new(
            position.X + (not textObj.Center and offset.X or 0),
            position.Y + offset.Y
        ))
        
        textLabel.Position = UDim2.fromOffset(offsetPos.X, offsetPos.Y)
    end
    
    textLabel:GetPropertyChangedSignal("TextBounds"):Connect(updatePosition)

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(textObj[index]) == "nil" then return end
            
            textObj[index] = value

            if index == "Text" then
                textLabel.Text = value
            elseif index == "Font" then
                value = math.clamp(value, 0, 3)
                textLabel.FontFace = getFontFromIndex(value)
            elseif index == "Size" then
                textLabel.TextSize = value
            elseif index == "Position" then
                updatePosition()
            elseif index == "Center" then
                updatePosition()
            elseif index == "Outline" then
                uiStroke.Enabled = value
            elseif index == "OutlineColor" then
                uiStroke.Color = value
            elseif index == "Visible" then
                textLabel.Visible = value
            elseif index == "ZIndex" then
                textLabel.ZIndex = value
            elseif index == "Transparency" then
                local transparency = convertTransparency(value)
                textLabel.TextTransparency = transparency
                uiStroke.Transparency = transparency
            elseif index == "Color" then
                textLabel.TextColor3 = value
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    textLabel:Destroy()
                    textObj.Remove(self)
                    return textObj:Remove()
                end
            elseif index == "TextBounds" then
                return textLabel.TextBounds
            end
            return textObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Circle implementation
drawingTypes.Circle = function()
    local circleObj = ({
        Radius = 150,
        Position = Vector2.zero,
        Thickness = 0.7,
        Filled = false
    } + baseDrawingObj)

    local circleFrame = Instance.new("Frame")
    local uiCorner = Instance.new("UICorner")
    local uiStroke = Instance.new("UIStroke")
    
    circleFrame.Name = drawingIndex
    circleFrame.AnchorPoint = Vector2.one * 0.5
    circleFrame.BorderSizePixel = 0
    circleFrame.BackgroundTransparency = (circleObj.Filled and convertTransparency(circleObj.Transparency) or 1)
    circleFrame.BackgroundColor3 = circleObj.Color
    circleFrame.Visible = circleObj.Visible
    circleFrame.ZIndex = circleObj.ZIndex
    
    uiCorner.CornerRadius = UDim.new(1, 0)
    circleFrame.Size = UDim2.fromOffset(circleObj.Radius * 2, circleObj.Radius * 2)
    
    uiStroke.Thickness = circleObj.Thickness
    uiStroke.Enabled = not circleObj.Filled
    uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    uiStroke.Color = circleObj.Color
    
    circleFrame.Parent = drawingUI
    uiCorner.Parent = circleFrame
    uiStroke.Parent = circleFrame
    
    local function updatePosition()
        local offsetPos = applyOffset(circleObj.Position)
        circleFrame.Position = UDim2.fromOffset(offsetPos.X, offsetPos.Y)
    end
    
    updatePosition()

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(circleObj[index]) == "nil" then return end
            
            circleObj[index] = value

            if index == "Radius" then
                local diameter = value * 2
                circleFrame.Size = UDim2.fromOffset(diameter, diameter)
            elseif index == "Position" then
                updatePosition()
            elseif index == "Thickness" then
                value = math.clamp(value, 0.6, 0x7fffffff)
                uiStroke.Thickness = value
            elseif index == "Filled" then
                circleFrame.BackgroundTransparency = (value and convertTransparency(circleObj.Transparency) or 1)
                uiStroke.Enabled = not value
            elseif index == "Visible" then
                circleFrame.Visible = value
            elseif index == "ZIndex" then
                circleFrame.ZIndex = value
            elseif index == "Transparency" then
                local transparency = convertTransparency(value)
                circleFrame.BackgroundTransparency = (circleObj.Filled and transparency or 1)
                uiStroke.Transparency = transparency
            elseif index == "Color" then
                circleFrame.BackgroundColor3 = value
                uiStroke.Color = value
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    circleFrame:Destroy()
                    circleObj.Remove(self)
                    return circleObj:Remove()
                end
            end
            return circleObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Square implementation
drawingTypes.Square = function()
    local squareObj = ({
        Size = Vector2.zero,
        Position = Vector2.zero,
        Thickness = 0.7,
        Filled = false
    } + baseDrawingObj)

    local squareFrame = Instance.new("Frame")
    local uiStroke = Instance.new("UIStroke")
    
    squareFrame.Name = drawingIndex
    squareFrame.BorderSizePixel = 0
    squareFrame.BackgroundTransparency = (squareObj.Filled and convertTransparency(squareObj.Transparency) or 1)
    squareFrame.ZIndex = squareObj.ZIndex
    squareFrame.BackgroundColor3 = squareObj.Color
    squareFrame.Visible = squareObj.Visible
    
    uiStroke.Thickness = squareObj.Thickness
    uiStroke.Enabled = not squareObj.Filled
    uiStroke.LineJoinMode = Enum.LineJoinMode.Miter
    uiStroke.Color = squareObj.Color
    
    squareFrame.Parent = drawingUI
    uiStroke.Parent = squareFrame
    
    local function updatePosition()
        local offsetPos = applyOffset(squareObj.Position)
        squareFrame.Position = UDim2.fromOffset(offsetPos.X, offsetPos.Y)
    end
    
    updatePosition()

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(squareObj[index]) == "nil" then return end
            
            squareObj[index] = value

            if index == "Size" then
                squareFrame.Size = UDim2.fromOffset(value.X, value.Y)
            elseif index == "Position" then
                updatePosition()
            elseif index == "Thickness" then
                value = math.clamp(value, 0.6, 0x7fffffff)
                uiStroke.Thickness = value
            elseif index == "Filled" then
                squareFrame.BackgroundTransparency = (value and convertTransparency(squareObj.Transparency) or 1)
                uiStroke.Enabled = not value
            elseif index == "Visible" then
                squareFrame.Visible = value
            elseif index == "ZIndex" then
                squareFrame.ZIndex = value
            elseif index == "Transparency" then
                local transparency = convertTransparency(value)
                squareFrame.BackgroundTransparency = (squareObj.Filled and transparency or 1)
                uiStroke.Transparency = transparency
            elseif index == "Color" then
                uiStroke.Color = value
                squareFrame.BackgroundColor3 = value
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    squareFrame:Destroy()
                    squareObj.Remove(self)
                    return squareObj:Remove()
                end
            end
            return squareObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Image implementation
drawingTypes.Image = function()
    local imageObj = ({
        Data = "",
        DataURL = "rbxassetid://0",
        Size = Vector2.zero,
        Position = Vector2.zero
    } + baseDrawingObj)

    local imageFrame = Instance.new("ImageLabel")
    
    imageFrame.Name = drawingIndex
    imageFrame.BorderSizePixel = 0
    imageFrame.ScaleType = Enum.ScaleType.Stretch
    imageFrame.BackgroundTransparency = 1
    imageFrame.Visible = imageObj.Visible
    imageFrame.ZIndex = imageObj.ZIndex
    imageFrame.ImageTransparency = convertTransparency(imageObj.Transparency)
    imageFrame.ImageColor3 = imageObj.Color
    
    imageFrame.Parent = drawingUI
    
    local function updatePosition()
        local offsetPos = applyOffset(imageObj.Position)
        imageFrame.Position = UDim2.fromOffset(offsetPos.X, offsetPos.Y)
    end
    
    updatePosition()

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(imageObj[index]) == "nil" then return end
            
            imageObj[index] = value

            if index == "Data" then
                -- To be implemented
            elseif index == "DataURL" then
                imageFrame.Image = value
            elseif index == "Size" then
                imageFrame.Size = UDim2.fromOffset(value.X, value.Y)
            elseif index == "Position" then
                updatePosition()
            elseif index == "Visible" then
                imageFrame.Visible = value
            elseif index == "ZIndex" then
                imageFrame.ZIndex = value
            elseif index == "Transparency" then
                imageFrame.ImageTransparency = convertTransparency(value)
            elseif index == "Color" then
                imageFrame.ImageColor3 = value
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    imageFrame:Destroy()
                    imageObj.Remove(self)
                    return imageObj:Remove()
                end
            elseif index == "Data" then
                return nil -- TODO: add error handling
            end
            return imageObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Triangle implementation
drawingTypes.Triangle = function()
    local triangleObj = ({
        PointA = Vector2.zero,
        PointB = Vector2.zero,
        PointC = Vector2.zero,
        Thickness = 1,
        Filled = false
    } + baseDrawingObj)

    local _linePoints = {
        A = DrawingLib.new("Line"),
        B = DrawingLib.new("Line"),
        C = DrawingLib.new("Line")
    }

    local function updatePoints()
        local pointA, pointB, pointC = triangleObj.PointA, triangleObj.PointB, triangleObj.PointC
        
        _linePoints.A.From = pointC
        _linePoints.A.To = pointA
        
        _linePoints.B.From = pointA
        _linePoints.B.To = pointB
        
        _linePoints.C.From = pointB
        _linePoints.C.To = pointC
    end

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(triangleObj[index]) == "nil" then return end
            
            triangleObj[index] = value

            if index == "PointA" or index == "PointB" or index == "PointC" then
                updatePoints()
            elseif index == "Thickness" or index == "Visible" or index == "Color" or index == "ZIndex" or index == "Transparency" then
                for _, linePoint in _linePoints do
                    linePoint[index] = value
                end
            elseif index == "Filled" then
                -- To be implemented
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    for _, linePoint in _linePoints do
                        linePoint:Remove()
                    end
                    triangleObj.Remove(self)
                    return triangleObj:Remove()
                end
            end
            return triangleObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Quad implementation
drawingTypes.Quad = function()
    local quadObj = ({
        PointA = Vector2.zero,
        PointB = Vector2.zero,
        PointC = Vector2.zero,
        PointD = Vector2.zero,
        Thickness = 1,
        Filled = false
    } + baseDrawingObj)

    local _linePoints = {
        A = DrawingLib.new("Line"),
        B = DrawingLib.new("Line"),
        C = DrawingLib.new("Line"),
        D = DrawingLib.new("Line")
    }

    local function updatePoints()
        local pointA, pointB, pointC, pointD = quadObj.PointA, quadObj.PointB, quadObj.PointC, quadObj.PointD
        
        _linePoints.A.From = pointD
        _linePoints.A.To = pointA
        
        _linePoints.B.From = pointA
        _linePoints.B.To = pointB
        
        _linePoints.C.From = pointB
        _linePoints.C.To = pointC
        
        _linePoints.D.From = pointC
        _linePoints.D.To = pointD
    end

    return setmetatable(table.create(0), {
        __newindex = function(_, index, value)
            if typeof(quadObj[index]) == "nil" then return end
            
            quadObj[index] = value

            if index == "PointA" or index == "PointB" or index == "PointC" or index == "PointD" then
                updatePoints()
            elseif index == "Thickness" or index == "Visible" or index == "Color" or index == "ZIndex" or index == "Transparency" then
                for _, linePoint in _linePoints do
                    linePoint[index] = value
                end
            elseif index == "Filled" then
                -- To be implemented
            end
        end,
        __index = function(self, index)
            if index == "Remove" or index == "Destroy" then
                return function()
                    for _, linePoint in _linePoints do
                        linePoint:Remove()
                    end
                    quadObj.Remove(self)
                    return quadObj:Remove()
                end
            end
            return quadObj[index]
        end,
        __tostring = function() return "Drawing" end
    })
end

-- Constructor function
function DrawingLib.new(drawingType)
    drawingIndex += 1
    
    local constructor = drawingTypes[drawingType]
    if constructor then
        return constructor()
    else
        error("Invalid drawing type: " .. tostring(drawingType))
    end
end

return DrawingLib
